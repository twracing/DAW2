var codeCoverage;!function(){"use strict";var e={d:function(t,r){for(var i in r)e.o(r,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:r[i]})},o:function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r:function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{getCodeCoverageData:function(){return d},getSerializedCodeCoverageDataChunks:function(){return u}});class r{size(){return 0}get(e){return{didOperationSucceed:!1,operationResult:!1}}set(e){return{didOperationSucceed:!1,operationResult:void 0}}clear(e){return{didOperationSucceed:!1,operationResult:void 0}}toggle(e){return{didOperationSucceed:!1,operationResult:void 0}}serialize(){return"0:"}getSerializedChunks(){return{didOperationSucceed:!0,operationResult:["total_bits=0,total_source_bytes=0,chunk_idx=0,total_chunks=1,offset_bytes=0,len_bytes=0,data_b64=INVALID_BIT_ARRAY_DATA"]}}constructor(){}}var i;function n(e){if(!(e instanceof Error))return{name:"NonError",message:String(e)};const t={name:e.name,message:e.message,stack:e.stack};!("code"in e)||"string"!=typeof e.code&&"number"!=typeof e.code||(t.code=e.code),"cause"in e&&e.cause instanceof Error&&(t.cause=n(e.cause));for(const r of Object.keys(e))r in t||(t[r]=e[r]);return t}!function(e){e.FixedSize="FixedSize",e.DynamicSize="DynamicSize"}(i||(i={}));class o{size(){return this._maxSize}ensureCapacity(e){const t=e+1;if(t>this._maxSize)return!1;if(t>this._capacityInBits){let e=Math.max(2*this._capacityInBits,t);e=Math.min(e,this._maxSize);const r=Math.ceil(e/8);if(r>this.storage.length)try{const e=new Uint8Array(r);e.set(this.storage),this.storage=e}catch(e){return!1}this._capacityInBits=8*this.storage.length}return!0}checkIndexOutOfBounds(e){return e<0||!Number.isInteger(e)||e>=this._maxSize}get(e){if(this.checkIndexOutOfBounds(e))return{didOperationSucceed:!1,error:`Index ${e} out of bounds [0, ${this._maxSize-1}].`};if(e>=this._logicalSize)return{didOperationSucceed:!0,operationResult:!1};try{const t=Math.floor(e/8),r=1<<e%8;return t>=this.storage.length?{didOperationSucceed:!1,error:`Internal error: Calculated byte index ${t} exceeds storage length ${this.storage.length} for logical size ${this._logicalSize}.`}:{didOperationSucceed:!0,operationResult:0!=(this.storage[t]&r)}}catch(e){return{didOperationSucceed:!1,error:JSON.stringify(n(e))}}}set(e){if(this.checkIndexOutOfBounds(e))return{didOperationSucceed:!1,error:`Index ${e} out of bounds [0, ${this._maxSize-1}].`};try{if(!this.ensureCapacity(e))return{didOperationSucceed:!1,error:`Failed to ensure capacity for index ${e}.`};const t=Math.floor(e/8),r=1<<e%8;return t>=this.storage.length?{didOperationSucceed:!1,error:`Internal error: Calculated byte index ${t} exceeds storage length ${this.storage.length} after ensureCapacity for index ${e}.`}:(this.storage[t]|=r,this._logicalSize=Math.max(this._logicalSize,e+1),{didOperationSucceed:!0})}catch(e){return{didOperationSucceed:!1,error:JSON.stringify(n(e))}}}clear(e){if(this.checkIndexOutOfBounds(e))return{didOperationSucceed:!1,error:`Index ${e} out of bounds [0, ${this._maxSize-1}].`};if(e>=this._logicalSize)return{didOperationSucceed:!0};try{const t=Math.floor(e/8),r=1<<e%8;return t>=this.storage.length?{didOperationSucceed:!1,error:`Internal error: Calculated byte index ${t} exceeds storage length ${this.storage.length} for logical size ${this._logicalSize}.`}:(this.storage[t]&=~r,{didOperationSucceed:!0})}catch(e){return{didOperationSucceed:!1,error:JSON.stringify(n(e))}}}toggle(e){if(this.checkIndexOutOfBounds(e))return{didOperationSucceed:!1,error:`Index ${e} out of bounds [0, ${this._maxSize-1}].`};try{if(!this.ensureCapacity(e))return{didOperationSucceed:!1,error:`Failed to ensure capacity for index ${e}.`};const t=Math.floor(e/8),r=1<<e%8;return t>=this.storage.length?{didOperationSucceed:!1,error:`Internal error: Calculated byte index ${t} exceeds storage length ${this.storage.length} after ensureCapacity for index ${e}.`}:(this.storage[t]^=r,this._logicalSize=Math.max(this._logicalSize,e+1),{didOperationSucceed:!0})}catch(e){return{didOperationSucceed:!1,error:JSON.stringify(n(e))}}}serialize(){const e=this._logicalSize;if(0===e)return"0:";const t=Math.ceil(e/8),r=this.storage.slice(0,Math.min(t,this.storage.length));let i="";const o=r.length;try{for(let e=0;e<o;e+=8192){const t=r.subarray(e,Math.min(e+8192,o));let n="";for(let e=0;e<t.length;e++)n+=String.fromCharCode(t[e]);i+=btoa(n)}}catch(t){return`${e}:[Serialization Error: ${JSON.stringify(n(t))}]`}return`${e}:${i}`}getSerializedChunks(){const e=this._logicalSize,t=Math.ceil(e/8);return function(e,t,r,i){if(!(e instanceof Uint8Array))return{didOperationSucceed:!1,error:"sourceBytes must be a Uint8Array."};if("number"!=typeof t||t<0||!Number.isInteger(t))return{didOperationSucceed:!1,error:"totalLogicalBits must be a non-negative integer."};if("number"!=typeof r||r<=0||!Number.isInteger(r))return{didOperationSucceed:!1,error:"maxBytesPerChunk must be a positive integer."};const n=[],o=i&&""!==i.trim()?`correlation_id=${i},`:"",a=e.length;if(0===a){const e=`${o}total_bits=${t},total_source_bytes=0,chunk_idx=0,total_chunks=1,offset_bytes=0,len_bytes=0,data_b64=`;return n.push(e),{didOperationSucceed:!0,operationResult:n}}const s=Math.ceil(a/r);for(let i=0;i<s;i++){const c=i*r,d=e.subarray(c,c+r);let u;try{let e="";for(let t=0;t<d.length;t++)e+=String.fromCharCode(d[t]);u=btoa(e)}catch(e){const t=e instanceof Error?e.message:String(e);return{didOperationSucceed:!1,error:`Failed to Base64 encode byte chunk ${i} (offset ${c}, length ${d.length}): ${t}`}}const l=`${o}total_bits=${t},total_source_bytes=${a},chunk_idx=${i},total_chunks=${s},offset_bytes=${c},len_bytes=${d.length},data_b64=${u}`;n.push(l)}return{didOperationSucceed:!0,operationResult:n}}(this.storage.slice(0,Math.min(t,this.storage.byteLength)),e,this.configuredMaxBytesPerChunk,this.configuredChunkCorrelationID)}constructor(e,t,r){this._maxSize=e,this._logicalSize=0;const i=0===e?0:Math.min(Math.max(1,8),Math.ceil(e/8));this.storage=new Uint8Array(i),this._capacityInBits=8*this.storage.length,this.configuredChunkCorrelationID=t,this.configuredMaxBytesPerChunk=r}}class a{markAsUsed(e){this.bitArray.set(e).didOperationSucceed||this.logger.logError(`Failed to set bit at index ${e}`)}getSerializedCodeCoverageData(){return this.bitArray.serialize()}getSerializedCodeCoverageDataChunks(){const e=this.bitArray.getSerializedChunks();return e.didOperationSucceed&&null!=e.operationResult?e.operationResult:(this.logger.logError("Failed to get serialized chunks"),[])}constructor(e,t){this.bitArray=e,this.logger=t}}class s{markAsUsed(e){}getSerializedCodeCoverageData(){return""}getSerializedCodeCoverageDataChunks(){return[]}}class c{logError(e){}}function d(){return null==window.__prodCodeCoverage__?"":window.__prodCodeCoverage__.getSerializedCodeCoverageData()}function u(){return null==window.__prodCodeCoverage__?[]:window.__prodCodeCoverage__.getSerializedCodeCoverageDataChunks()}!function(){if(null!=window.__prodCodeCoverage__)return;const e=function(e){const t=function(e){const t=new r;let n,a,s=2048;if(e.serializationOptions&&(a=e.serializationOptions.chunkCorrelationID,void 0!==e.serializationOptions.maxBytesPerChunk)){const r=e.serializationOptions.maxBytesPerChunk;if("number"!=typeof r||!Number.isInteger(r)||r<=0)return{didCreationSucceed:!1,bitArray:t,error:`Invalid maxBytesPerChunk (${r}) in serializationOptions. Must be a positive integer.`};s=r}if(e.type===i.FixedSize){const r=e.size;if("number"!=typeof r||!Number.isInteger(r)||r<0)return{didCreationSucceed:!1,bitArray:t,error:`Invalid or missing size (${r}) provided for FixedSize BitArray. Size must be a non-negative integer.`};if(r>1e4)return{didCreationSucceed:!1,bitArray:t,error:`Invalid size (${r}) for FixedSize BitArray. Size exceeds the maximum allowed limit of 10000.`};try{n=new o(r,a,s)}catch(e){return{didCreationSucceed:!1,bitArray:t,error:`Failed to create internal BitArray for size ${r}: ${e instanceof Error?e.message:String(e)}`}}}else{if(e.type!==i.DynamicSize)return{didCreationSucceed:!1,bitArray:t,error:`Unsupported BitArray type requested: ${"number"==typeof e.type?i[e.type]||`UnknownType(${e.type})`:String(e.type)}. Only FixedSize and DynamicSize are supported by this factory.`};{const r=void 0!==e.size&&"number"==typeof e.size&&Number.isInteger(e.size)&&e.size>=0?e.size:0;try{n=new o(r,a,s)}catch(e){return{didCreationSucceed:!1,bitArray:t,error:`Failed to create dynamic BitArray with initial capacity ${r}: ${e instanceof Error?e.message:String(e)}`}}}}return{didCreationSucceed:!0,bitArray:n}}({type:i.DynamicSize,size:1e5}),n=null==e?new c:e;return t.didCreationSucceed?new a(t.bitArray,n):(n.logError(`Failed to create BitArray: ${t.error}`),new s)}();window.__prodCodeCoverage__=e}(),codeCoverage=t}();
//# sourceMappingURL=https://artifacts.dev.azure.com/office/_apis/symbol/symsrv/codeCoverage.min.js.map/590e526ee83c2179783b2286f0eb5eed/codeCoverage.min.js.map